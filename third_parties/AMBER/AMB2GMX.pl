#!/usr/bin/perl

# CHANGELOG
# release 14.6.a                - support for cpptraj
#
# release 14.5.b                - interactive mode for options confirmation
#                               - paths for GROMACS commands
#                               - USAGE block removed
#                               - selecting groups from index file
#
# release 14.5.a                - initial release


use strict;
use warnings;
use Carp;

# to make STDOUT flush immediately, simply set the variable
# this can be useful if you are writing to STDOUT in a loop
# many times the buffering will cause unexpected output results
$| = 1;

# paths di librerie personali
use lib $ENV{HOME};

# il metodo Dumper restituisce una stringa (con ritorni a capo \n)
# contenente la struttura dati dell'oggetto in esame.
#
# Esempio:
#   $obj = Class->new();
#   print Dumper($obj);
use Data::Dumper;
###################################################################
use Cwd;
use threads;

## GLOBS ##
our $workdir = getcwd();
our $AMBERHOME = $ENV{'AMBERHOME'};
our $bins = { # file binari
    'ptraj'     =>  $AMBERHOME . "/bin/ptraj\n",
    'trjconv'   => qx/which trjconv/,
    'trjcat'    => qx/which trjcat/,
    'makendx'   => qx/which make_ndx/,
    'editconf'   => qx/which editconf/,
};
our $inputs = {
    'prmtop'    => 'null',
    'inpcrd'    => 'null',
    'mdcrd' => 'null',
};
our $options = {
    'skip'      => 1,
    'first'     => 1,
    'last'      => 1000,
    'filename'  => 'null'
};
our @thr;
our $selected;
our $is_cpptraj;
## SBLOG ##

INIT: {
    my $splash = <<END
********************************************************************************
AMB2GMX
release 14.6.a

Copyright (c) 2014, Dario CORRADA <dario.corrada\@gmail.com>

Based on Trajectory Converter - v1.5
Copyright (c) 2008 Justin LEMKUL <jalemkul\@vt.edu>

This program is free software; you can redistribute it and/or modify it under 
the terms of the GNU General Public License as published by the Free Software 
Foundation; either version 2 of the License, or (at your option) any later 
version.
********************************************************************************

This script converts a series of .pdb files generated by ptraj to a Gromacs 
compatible trajectory for further analysis. This script requires a working 
installation of AMBER 12 and Gromacs 4.5.5 or later. Earlier versions of these 
packages may work, but have not been explicitly tested.

You must have the following files in the working directory:
  
  1. Your t0 structure file (inpcrd or rst7);
  2. Your trajectory file (mdcrd)
  3. Your topology file (prmtop)

END
    ;
    print $splash;
    
    # verifico quale ptraj usare
    chomp $bins->{'ptraj'};
    unless (-e $bins->{'ptraj'}) {
        print "\n\nptraj is not available, should I look for cpptraj? [Y/n] ";
        my $ans = <STDIN>;
        chomp $ans;
        $ans = 'y' unless ($ans);
        if ($ans =~ /[Yy]/) {
            $bins->{'ptraj'} = $AMBERHOME . "/bin/cpptraj\n";
            $is_cpptraj = 1;
        }
    }

    # verifico che i binari ci siano tutti
    foreach my $key (keys %{$bins}) {
        chomp $bins->{$key};
        if (-e $bins->{$key}) {
            next;
        } else {
            croak "\nE- file <$bins->{$key}> not found\n\t";
        }
    }
    
    # verifico che i file di input ci siano tutti
    opendir(INS, $workdir);
    my @content = readdir(INS);
    closedir INS;
    ($inputs->{'prmtop'}) = grep { /\.prmtop$/ } @content;
    ($inputs->{'inpcrd'}) = grep { /\.(inpcrd|rst7)$/ } @content;
    ($inputs->{'mdcrd'}) = grep { /(\.mdcrd|\.nc)$/ } @content;
    
    foreach my $key (keys %{$inputs}) {
        if ($inputs->{$key}) {
            next;
        } else {
            croak "\nE- input file <$key> not found\n\t";
        }
    }
    
    # chiedo conferma che tutti i parametri siano ok
    my $ans;
    
    printf("First frame to sample [%s]: ", $options->{'first'});
    $ans = <STDIN>; chomp $ans;
    $options->{'first'} = $ans if ($ans && !($options->{'first'} eq $ans));
    
    printf("Last frame to sample [%s]: ", $options->{'last'});
    $ans = <STDIN>; chomp $ans;
    $options->{'last'} = $ans if ($ans && !($options->{'last'} eq $ans));
    
    printf("Skip every i-th frames [%s]: ", $options->{'skip'});
    $ans = <STDIN>; chomp $ans;
    $options->{'skip'} = $ans if ($ans && !($options->{'skip'} eq $ans));
    
    ($options->{'filename'}) = $inputs->{'mdcrd'} =~ /(.+)\.mdcrd$/;
    printf("Outputs base name [%s]: ", $options->{'filename'});
    $ans = <STDIN>; chomp $ans;
    $options->{'filename'} = $ans if ($ans && !($options->{'filename'} eq $ans));
    
    foreach my $key (keys %{$inputs}) {
        printf("\n  %s => %s", $key, $inputs->{$key});
    }
    print "\n\nInput files are alright? [Y/n] ";
    $ans = <STDIN>;
    chomp $ans;
    $ans = 'y' unless ($ans);
    unless ($ans =~ /[Yy]/) {
        print "\naborting";
        goto FINE;
    } 
}

AMBERSIDE: {
    # Create ptraj input files
    my %ptraj;
    $ptraj{'ptraj_full.in'} = <<END
trajin $inputs->{'mdcrd'} $options->{'first'} $options->{'last'} $options->{'skip'}
trajout mdcrd.pdb pdb

END
    ;
    $ptraj{'ptraj_inpcrd.in'} = <<END
trajin $inputs->{'inpcrd'}
trajout mdcrd_0.pdb pdb

END
    ;
    foreach my $filename (keys %ptraj) {
        open(PIETRO, '>' . $filename);
        print PIETRO $ptraj{$filename};
        close PIETRO;
    }
    
    printf("*** %s running ptraj ***\n\n", clock());
    system("$bins->{'ptraj'} $inputs->{'prmtop'} ptraj_inpcrd.in");
    system("mv -v mdcrd_0.pdb.1 mdcrd_0.pdb");
    system("$bins->{'ptraj'} $inputs->{'prmtop'} ptraj_full.in");
}

goto NDX if ($is_cpptraj);

RENAME: {
    printf("\n*** %s renaming pdb snapshots ***\n\n", clock());
    opendir(OUTS, $workdir);
    my @file_list = readdir(OUTS);
    closedir OUTS;
    
    @file_list = grep { /^mdcrd\.pdb\./ } @file_list;
    while (my $filename = shift @file_list) {
        my ($num) = $filename =~ /^mdcrd\.pdb\.(\d+)$/;
        my $newname = sprintf("mdcrd.%05i.pdb", $num);
        system("mv -v $filename $newname");
    }
}

NDX: {
    # cerco i gruppi per proteina (e ligando)
    printf("\n*** %s creating index file ***\n\n", clock());
    my @log = qx/echo "q" | $bins->{'makendx'} -f mdcrd_0.pdb 2>&1/;
    while (my $newline = shift @log) {
        chomp $newline;
        if ($newline =~ /:\s+\d+ atoms$/) {
            print "$newline\n";
        }
    }
    
    my @groups = ( '1' );
    print "\nWhich of these groups you would retain? [@groups] ";
    my $ans = <STDIN>; chomp $ans;
    @groups = split(" ", $ans) if ($ans);
    my $joined = join(' | ', @groups);
    
    my $cmd = "$bins->{'makendx'} -f mdcrd_0.pdb <<EOF";
    $cmd .= "\n$joined\nq\nEOF";
    system("$cmd");
    
    undef @groups;
    @log = qx/echo "q" | $bins->{'makendx'} -f mdcrd_0.pdb -n index.ndx 2>&1/;
    while (my $newline = shift @log) {
        chomp $newline;
        if ($newline =~ /:\s+\d+ atoms$/) {
            push(@groups, $newline);
        }
    }
    my $newgroup = pop @groups;
    ($selected) = $newgroup =~ /^\s*(\d+)/;
}

goto CPPTRAJ if ($is_cpptraj);

TRJCONV: {
    printf("\n*** %s running trjconv ***\n\n", clock());
    opendir(OUTS, $workdir);
    my @file_list = readdir(OUTS);
    closedir OUTS;
    
    @file_list = grep { /^mdcrd\.\d+\.pdb$/ } @file_list;
    @file_list = sort { $a cmp $b } @file_list;
    my $remnants = scalar @file_list;
    my $threadnum = 16; # lancio trjconv a blocchi di $threadnum per volta
    while ($remnants) {
        for (my $i = 0; $i < $threadnum; $i++) {
            my $filename = shift @file_list;
            if ($filename) {
                print "converting $filename\n";
                push @thr, threads->new(\&pdb2xtc, $filename);
            }
            $remnants = scalar @file_list;
        }
        for (@thr) { $_->join() };
        undef @thr;
    }
}

TRJCAT: {
    printf("\n*** %s concatenating snapshots ***\n\n", clock());
    system("$bins->{'trjcat'} -f traj_?????.xtc -o $options->{'filename'}.start.xtc");
    system("echo $selected | $bins->{'editconf'} -f mdcrd_0.pdb -o $options->{'filename'}.gro -n index.ndx");
    system("echo $selected | $bins->{'trjconv'} -f $options->{'filename'}.start.xtc -s $options->{'filename'}.gro -timestep $options->{'skip'} -o $options->{'filename'}.xtc -n index.ndx");
}

CPPTRAJ: {
    printf("\n*** %s running trjconv ***\n\n", clock());
    system("echo $selected | $bins->{'editconf'} -f mdcrd_0.pdb -o $options->{'filename'}.gro -n index.ndx");
    system("echo $selected | $bins->{'trjconv'} -f mdcrd.pdb -s $options->{'filename'}.gro -timestep $options->{'skip'} -o $options->{'filename'}.xtc -n index.ndx");
}

CLEANSWEEP: {
    printf("\n*** %s cleaning temporary files ***\n\n", clock());
    my $cmd = <<END
rm *.pdb
rm traj_?????.xtc
rm *.start.xtc
rm ptraj_*.in
rm index.ndx
rm \\#*
END
    ;
    if ($is_cpptraj) {
        $cmd = <<END
rm *.pdb
rm ptraj_*.in
rm index.ndx
rm \\#*
END
        ;
    }
    qx/$cmd/;
}

FINE: {
    print "\n\n*** XMG2BMA ***\n";
    exit;
}

sub clock {
    my ($sec,$min,$ore,$giom,$mese,$anno,$gios,$gioa,$oraleg) = localtime(time);
    $mese = $mese+1;
    $mese = sprintf("%02d", $mese);
    $giom = sprintf("%02d", $giom);
    $ore = sprintf("%02d", $ore);
    $min = sprintf("%02d", $min);
    $sec = sprintf("%02d", $sec);
    my $date = '[' . ($anno+1900)."/$mese/$giom $ore:$min:$sec]";
    return $date;
}

sub pdb2xtc {
    my ($filename) = @_;
    my ($num) = $filename =~ /^mdcrd\.(\d+)\.pdb$/;
    my $cmdline = sprintf("echo 0 | $bins->{'trjconv'} -s %s -f %s -o traj_%05i.xtc -t0 %i", $filename, $filename, $num, $num);
    qx/$cmdline 2>&1/;
}