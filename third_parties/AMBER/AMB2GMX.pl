#!/usr/bin/perl
# -d

use strict;
use warnings;
use Carp;

# to make STDOUT flush immediately, simply set the variable
# this can be useful if you are writing to STDOUT in a loop
# many times the buffering will cause unexpected output results
$| = 1;

# paths di librerie personali
use lib $ENV{HOME};

# il metodo Dumper restituisce una stringa (con ritorni a capo \n)
# contenente la struttura dati dell'oggetto in esame.
#
# Esempio:
#   $obj = Class->new();
#   print Dumper($obj);
use Data::Dumper;
###################################################################
use Cwd;
use threads;

## GLOBS ##
our $workdir = getcwd();
our $AMBERHOME = $ENV{'AMBERHOME'};
our $bins = { # file binari
    'ptraj'     =>  $AMBERHOME . '/bin/ptraj',
};
our $inputs = {
    'prmtop'    => 'null',
    'inpcrd'    => 'null',
    'mdcrd' => 'null',
};
our $options = {
    'skip'      => 1,
    'first'     => 1,
    'last'      => 1000,
    'filename'  => 'null'
};
our @thr;
## SBLOG ##

USAGE: {
    use Getopt::Long;no warnings;
    GetOptions($options, 'help|h', 'skip=i', 'first=i', 'last=i');
    my $usage = <<END
********************************************************************************
AMB2GMX
release 14.5.a

Copyright (c) 2014, Dario CORRADA <dario.corrada\@gmail.com>

Based on Trajectory Converter - v1.5
Copyright (c) 2008 Justin LEMKUL <jalemkul\@vt.edu>

This program is free software; you can redistribute it and/or modify it under 
the terms of the GNU General Public License as published by the Free Software 
Foundation; either version 2 of the License, or (at your option) any later 
version.
********************************************************************************

This script converts a series of .pdb files generated by ptraj to a Gromacs 
compatible trajectory for further analysis. This script requires a working 
installation of AMBER 12 and Gromacs 4.5.5 or later. Earlier versions of these 
packages may work, but have not been explicitly tested.

You must have the following files in the working directory:

  1. Your t0 structure file (inpcrd or rst7);
  2. Your trajectory file (mdcrd)
  3. Your topology file (prmtop)

SYNOPSIS
    
    \$ AMB2GMX.pl

OPTIONS
    -skip   <int>       read only every int frame (default 1); this value will
                        be also used as timestep by trjconv (in ps)
    
    -first  <int>       first frame to read (default 1)
    
    -last   <int>       last frame to read (default 1000)
END
    ;
    if (exists $options->{'help'}) {
        print $usage;
        goto FINE;
    }
}

INIT: {
    my $splash = <<END
********************************************************************************
AMB2GMX
release 14.5.a

Copyright (c) 2014, Dario CORRADA <dario.corrada\@gmail.com>

Based on Trajectory Converter - v1.5
Copyright (c) 2008 Justin LEMKUL <jalemkul\@vt.edu>

This program is free software; you can redistribute it and/or modify it under 
the terms of the GNU General Public License as published by the Free Software 
Foundation; either version 2 of the License, or (at your option) any later 
version.
********************************************************************************
END
    ;
    print $splash;
    
    # verifico che i binari ci siano tutti
    foreach my $key (keys %{$bins}) {
        if (-e $bins->{$key}) {
            next;
        } else {
            croak "\nE- file <$bins->{$key}> not found\n\t";
        }
    }
    
    # verifico che i file di input ci siano tutti
    opendir(INS, $workdir);
    my @content = readdir(INS);
    closedir INS;
    ($inputs->{'prmtop'}) = grep { /\.prmtop$/ } @content;
    ($inputs->{'inpcrd'}) = grep { /\.(inpcrd|rst7)$/ } @content;
    ($inputs->{'mdcrd'}) = grep { /\.mdcrd$/ } @content;
    unless ($inputs->{'mdcrd'} eq 'null') {
        ($options->{'filename'}) = $inputs->{'mdcrd'} =~ /(.+)\.mdcrd$/;
    }
    
    foreach my $key (keys %{$inputs}) {
        if ($inputs->{$key} eq 'null') {
            croak "\nE- file <$inputs->{$key}> not found\n\t";
        } else {
            next;
        }
    }
    
    # chiedo conferma che tutti i parametri siano ok
    my $ans;
    print"\n[ inputs ]\n";
    foreach my $key (keys %{$inputs}) {
        printf("% 12s => %s\n", $key, $inputs->{$key});
    }
    print"\n[ parameters ]\n";
    foreach my $key (keys %{$options}) {
        printf("% 12s => %s\n", $key, $options->{$key});
    }
    print "\nIs it alright? [Y/n] ";
    $ans = <STDIN>;
    chomp $ans;
    $ans = 'y' unless ($ans);
    if ($ans =~ /[Yy]/) {
        print "\n>>> HEY HO LET'S GO <<<\n\n";
    } else {
        print "\ntype \"AMB2GMX.pl -h\" to see the avalaible options\n";
        goto FINE;
    } 
}

AMBERSIDE: {
    # Create ptraj input files
    my %ptraj;
    $ptraj{'ptraj_full.in'} = <<END
trajin $inputs->{'mdcrd'} $options->{'first'} $options->{'last'} $options->{'skip'}
trajout mdcrd.pdb pdb

END
    ;
    $ptraj{'ptraj_inpcrd.in'} = <<END
trajin $inputs->{'inpcrd'}
trajout mdcrd_0.pdb pdb

END
    ;
    foreach my $filename (keys %ptraj) {
        open(PIETRO, '>' . $filename);
        print PIETRO $ptraj{$filename};
        close PIETRO;
    }
    
    printf("*** %s running ptraj ***\n\n", clock());
    system("$bins->{'ptraj'} $inputs->{'prmtop'} ptraj_inpcrd.in");
    system("mv -v mdcrd_0.pdb.1 mdcrd_0.pdb");
    system("$bins->{'ptraj'} $inputs->{'prmtop'} ptraj_full.in");
}

RENAME: {
    printf("\n*** %s renaming pdb snapshots ***\n\n", clock());
    opendir(OUTS, $workdir);
    my @file_list = readdir(OUTS);
    closedir OUTS;
    
    @file_list = grep { /^mdcrd\.pdb\./ } @file_list;
    while (my $filename = shift @file_list) {
        my ($num) = $filename =~ /^mdcrd\.pdb\.(\d+)$/;
        my $newname = sprintf("mdcrd.%05i.pdb", $num);
        system("mv -v $filename $newname");
    }
}

#
# Questo blocco serve per crearsi un index file custom ed estrarre la 
# traiettoria usando quello come filtro. Occorre perÃ² modificare anche il 
# codice a valle per renderlo effettivo.
# 
# NDX: {
#     # cerco i gruppi per proteina (e ligando)
#     printf("\n*** %s creating index file ***\n\n", clock());
#     my @log = qx/echo "q" | make_ndx -f mdcrd_0.pdb 2>&1/;
#     my @groups;
#     while (my $newline = shift @log) {
#         chomp $newline;
#         if ($newline =~ /:\s+\d+ atoms$/) {
#             if ($newline =~ /( Protein | Other )/) {
#                 next;
# #                 print "retain group [$newline]\n";
#             } else {
#                 my ($num) = $newline =~ /^\s+(\d+)/;
#                 push(@groups, $num);
#             }
#         }
#     }
#     unlink "index.ndx";
#     
#     my $cmd = 'make_ndx -f mdcrd_0.pdb <<EOF';
#     while (my $i = pop @groups) {
#         $cmd .= "\ndel $i";
#     }
#     $cmd .= "\nq\nEOF";
#     print "[$cmd]";
#     system("$cmd");
# }
#

TRJCONV: {
    printf("\n*** %s running trjconv ***\n\n", clock());
    opendir(OUTS, $workdir);
    my @file_list = readdir(OUTS);
    closedir OUTS;
    
    @file_list = grep { /^mdcrd\.\d+\.pdb$/ } @file_list;
    @file_list = sort { $a cmp $b } @file_list;
    my $remnants = scalar @file_list;
    my $threadnum = 16; # lancio trjconv a blocchi di $threadnum per volta
    while ($remnants) {
        for (my $i = 0; $i < $threadnum; $i++) {
            my $filename = shift @file_list;
            if ($filename) {
                print "converting $filename\n";
                push @thr, threads->new(\&pdb2xtc, $filename);
            }
            $remnants = scalar @file_list;
        }
        for (@thr) { $_->join() };
        undef @thr;
    }
}

TRJCAT: {
    printf("\n*** %s concatenating snapshots ***\n\n", clock());
    system("trjcat -f traj_?????.xtc -o $options->{'filename'}.start.xtc");
    system("echo 0 | editconf -f mdcrd_0.pdb -o $options->{'filename'}.gro");
    system("echo 0 | trjconv -f $options->{'filename'}.start.xtc -s $options->{'filename'}.gro -timestep $options->{'skip'} -o $options->{'filename'}.xtc");
}

CLEANSWEEP: {
    printf("\n*** %s cleaning temporary files ***\n\n", clock());
    my $cmd = <<END
rm *.pdb
rm traj_?????.xtc
rm *.start.xtc
rm ptraj_*.in
END
    ;
    qx/$cmd/;
}

FINE: {
    print "\n\n*** XMG2BMA ***\n";
    exit;
}

sub clock {
    my ($sec,$min,$ore,$giom,$mese,$anno,$gios,$gioa,$oraleg) = localtime(time);
    $mese = $mese+1;
    $mese = sprintf("%02d", $mese);
    $giom = sprintf("%02d", $giom);
    $ore = sprintf("%02d", $ore);
    $min = sprintf("%02d", $min);
    $sec = sprintf("%02d", $sec);
    my $date = '[' . ($anno+1900)."/$mese/$giom $ore:$min:$sec]";
    return $date;
}

sub pdb2xtc {
    my ($filename) = @_;
    my ($num) = $filename =~ /^mdcrd\.(\d+)\.pdb$/;
    my $cmdline = sprintf("echo 0 | trjconv -s %s -f %s -o traj_%05i.xtc -t0 %i", $filename, $filename, $num, $num);
    qx/$cmdline 2>&1/;
}